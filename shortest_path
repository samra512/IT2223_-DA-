----------------Dijkstra-----------------

% Define the weighted adjacency matrix
adjMatrix = [
    0 2 0 1 0;
    2 0 4 3 0;
    0 4 0 0 6;
    1 3 0 0 5;
    0 0 6 5 0;
];

% Create and plot the graph
G = graph(adjMatrix);
figure;
plot(G, 'Layout', 'force', 'EdgeLabel', G.Edges.Weight);
title("Weighted Adjacency Matrix");

% Replace 0s with Inf (except diagonal)
n = size(adjMatrix, 1);
for i = 1:n
    for j = 1:n
        if i ~= j && adjMatrix(i, j) == 0
            adjMatrix(i, j) = Inf;
        end
    end
end

% Dijkstraâ€™s Algorithm
startNode = 1;
visited = false(1, n);
distance = Inf(1, n);
distance(startNode) = 0;

for i = 1:n
    minDist = Inf;
    u = -1;
    for j = 1:n
        if ~visited(j) && distance(j) < minDist
            minDist = distance(j);
            u = j;
        end 
    end

    if u == -1  % No valid node left to process
        break;
    end

    visited(u) = true;

    for v = 1:n
        if ~visited(v) && adjMatrix(u, v) ~= Inf
            if distance(u) + adjMatrix(u, v) < distance(v)
                distance(v) = distance(u) + adjMatrix(u, v);
            end
        end
    end
end

% Display the results
fprintf('Shortest Distance from Source Node (%d):\n', startNode);
for i = 1:n
    fprintf('Vertex %d: %d\n', i, distance(i));
end

% ------------------------------------------
% > dijkstras
% Shortest Distance from Source Node (1):
% Vertex 1: 0
% Vertex 2: 2
% Vertex 3: 6
% Vertex 4: 1
% Vertex 5: 6

-------------------------------------------------------------------------------

------------------Salsman---------------

% Define the distance matrix between cities
dist = [ 0 10 15 20;
10 0 35 25;
15 35 0 30;
20 25 30 0];

% Generate all permutations of cities 2, 3, and 4
allPerms = perms([2 3 4]); % generates all permutations of the input vector.

% sorts the rows of a matrix in ascending order by default.
sortedPerms = sortrows(allPerms);

% Display the order of permutations checked
disp('Permutations checked in this order:');
disp(sortedPerms);
minDist = inf;
bestPath = [];
for i = 1:size(sortedPerms, 1)
currentPath = [1 sortedPerms(i,:) 1];
currentDist = 0;
for j = 1:length(currentPath)-1
currentDist = currentDist + dist(currentPath(j), currentPath(j+1));
end
if currentDist < minDist
minDist = currentDist;
bestPath = currentPath;
end
end

disp('Shortest Path:');
disp(bestPath);

disp('Minimum Distance:');
disp(minDist);

---------------------------------
output:

Permutations checked in this order:
     2     3     4
     2     4     3
     3     2     4
     3     4     2
     4     2     3
     4     3     2

Shortest Path:
     1     2     4     3     1

Minimum Distance:
    80



